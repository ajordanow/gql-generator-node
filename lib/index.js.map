{"version":3,"sources":["../src/index.js"],"names":["generateQuery","field","rootField","skeleton","rootSkeleton","kind","depthLimit","dedupe","getFieldArgsDict","generateQueryRecursive","parentName","argumentsDict","duplicateArgCounts","crossReferenceKeyList","curDepth","path","curType","type","ofType","queryStr","childQuery","getFields","crossReferenceKey","name","indexOf","push","children","Object","entries","skeletonKeys","keys","filter","key","map","childField","concat","cur","join","repeat","args","length","dict","assign","astNode","types","getTypes","indent","fragIndent","forEach","unionChildQuery","wrapQueryIntoKindDeclaration","alias","queryResult","varsToTypesStr","query","toLowerCase","generateAll","schema","result","QUERY_KINDS_MAP","Query","Mutation","Subscription","addToResult","obj","description","moduleConsole","warn","String","getMutationType","getQueryType","getSubscriptionType"],"mappings":"AAAA;;;;;;;;;AAEA;;AAEA;;;;;;;;AAQO,MAAMA,aAAa,GAAG,CAAC;AACCC,EAAAA,KAAK,EAAEC,SADR;AAECC,EAAAA,QAAQ,EAAEC,YAFX;AAGCC,EAAAA,IAAI,GAAG,OAHR;AAICC,EAAAA,UAJD;AAKCC,EAAAA,MAAM,GAAGC;AALV,CAAD,KAMvB;AAEL;;;;;;;;;;;AAWA,QAAMC,sBAAsB,GAAG,CAAC;AACCR,IAAAA,KADD;AAECE,IAAAA,QAFD;AAGCO,IAAAA,UAHD;AAICC,IAAAA,aAAa,GAAG,EAJjB;AAKCC,IAAAA,kBAAkB,GAAG,EALtB;AAMCC,IAAAA,qBAAqB,GAAG,EANzB;AAM6B;AAC5BC,IAAAA,QAAQ,GAAG,CAPZ;AAQCC,IAAAA,IAAI,GAAG;AARR,GAAD,KASO;AACrC,QAAIC,OAAO,GAAGf,KAAK,CAACgB,IAApB;;AACA,WAAOD,OAAO,CAACE,MAAf,EAAuBF,OAAO,GAAGA,OAAO,CAACE,MAAlB;;AAEvB,QAAIC,QAAQ,GAAG,EAAf;AACA,QAAIC,UAAU,GAAG,EAAjB;;AAEA,QAAIJ,OAAO,CAACK,SAAZ,EAAuB;AACtB,YAAMC,iBAAiB,GAAI,GAAEZ,UAAW,KAAIT,KAAK,CAACsB,IAAK,KAAvD;AACA,UAAIV,qBAAqB,CAACW,OAAtB,CAA8BF,iBAA9B,MAAqD,CAAC,CAAtD,IAA2DR,QAAQ,GAAGR,UAA1E,EAAsF,OAAO,EAAP;AACtFO,MAAAA,qBAAqB,CAACY,IAAtB,CAA2BH,iBAA3B;AACA,YAAMI,QAAQ,GAAGV,OAAO,CAACK,SAAR,EAAjB;AACAD,MAAAA,UAAU,GAAGO,MAAM,CAACC,OAAP,CAAeF,QAAf,CAAb;;AACA,UAAIvB,QAAJ,EAAc;AACb,cAAM0B,YAAY,GAAGF,MAAM,CAACG,IAAP,CAAY3B,QAAZ,CAArB;AACAiB,QAAAA,UAAU,GAAGA,UAAU,CACrBW,MADW,CACJ,CAAC,CAACC,GAAD,CAAD,KAAWH,YAAY,CAACL,OAAb,CAAqBQ,GAArB,MAA8B,CAAC,CADtC,CAAb;AAEA,OAJD,MAIO7B,QAAQ,GAAG,EAAX;;AACPiB,MAAAA,UAAU,GAAGA,UAAU,CACrBa,GADW,CACP,CAAC,CAACD,GAAD,EAAME,UAAN,CAAD,KAAuBzB,sBAAsB,CAAC;AAClDR,QAAAA,KAAK,EAAEiC,UAD2C;AAElD/B,QAAAA,QAAQ,EAAEA,QAAQ,CAAC6B,GAAD,CAFgC;AAGlDtB,QAAAA,UAAU,EAAET,KAAK,CAACsB,IAHgC;AAIlDZ,QAAAA,aAJkD;AAKlDC,QAAAA,kBALkD;AAMlDC,QAAAA,qBANkD;AAOlDC,QAAAA,QAAQ,EAAEA,QAAQ,GAAG,CAP6B;AAQlDC,QAAAA,IAAI,EAAEA,IAAI,CAACoB,MAAL,CAAYlC,KAAK,CAACsB,IAAlB;AAR4C,OAAD,CAAtB,CASzBJ,QAVS,EAWXY,MAXW,CAWJK,GAAG,IAAIA,GAXH,EAYXC,IAZW,CAYN,IAZM,CAAb;AAaA;;AAED,QAAI,EAAErB,OAAO,CAACK,SAAR,IAAqB,CAACD,UAAxB,CAAJ,EAAyC;AACxCD,MAAAA,QAAQ,GAAI,GAAE,OAAOmB,MAAP,CAAcxB,QAAd,CAAwB,GAAEb,KAAK,CAACsB,IAAK,EAAnD;;AACA,UAAItB,KAAK,CAACsC,IAAN,CAAWC,MAAX,GAAoB,CAAxB,EAA2B;AAC1B,cAAMC,IAAI,GAAGlC,MAAM,CAACN,KAAD,EAAQW,kBAAR,EAA4BD,aAA5B,EAA2CI,IAA3C,CAAnB;AACAY,QAAAA,MAAM,CAACe,MAAP,CAAc/B,aAAd,EAA6B8B,IAA7B;AACAtB,QAAAA,QAAQ,IAAK,IAAG,6BAAiBsB,IAAjB,CAAuB,GAAvC;AACA;;AACD,UAAIrB,UAAJ,EAAgB;AACfD,QAAAA,QAAQ,IAAK,MAAKC,UAAW,KAAI,OAAOkB,MAAP,CAAcxB,QAAd,CAAwB,GAAzD;AACA;AACD;AAED;;;AACA,QAAIE,OAAO,CAAC2B,OAAR,IAAmB3B,OAAO,CAAC2B,OAAR,CAAgBtC,IAAhB,KAAyB,qBAAhD,EAAuE;AACtE,YAAMuC,KAAK,GAAG5B,OAAO,CAAC6B,QAAR,EAAd;;AACA,UAAID,KAAK,IAAIA,KAAK,CAACJ,MAAnB,EAA2B;AAC1B,cAAMM,MAAM,GAAI,GAAE,OAAOR,MAAP,CAAcxB,QAAd,CAAwB,EAA1C;AACA,cAAMiC,UAAU,GAAI,GAAE,OAAOT,MAAP,CAAcxB,QAAQ,GAAG,CAAzB,CAA4B,EAAlD;AACAK,QAAAA,QAAQ,IAAI,KAAZ;AAEAyB,QAAAA,KAAK,CAACI,OAAN,CAAc/B,IAAI,IAAI;AACrB,cAAIgC,eAAe,GAAGtB,MAAM,CAACC,OAAP,CAAeX,IAAI,CAACI,SAAL,EAAf,CAAtB;;AACA,cAAIlB,QAAQ,IAAIwB,MAAM,CAACG,IAAP,CAAY3B,QAAZ,EAAsBqC,MAAtC,EAA8C;AAC7C,kBAAMX,YAAY,GAAGF,MAAM,CAACG,IAAP,CAAY3B,QAAZ,CAArB;AACA8C,YAAAA,eAAe,GAAGA,eAAe,CAC/BlB,MADgB,CACT,CAAC,CAACC,GAAD,CAAD,KAAWH,YAAY,CAACL,OAAb,CAAqBQ,GAArB,MAA8B,CAAC,CADjC,CAAlB;AAEA,WAJD,MAIO7B,QAAQ,GAAG,EAAX;;AACP8C,UAAAA,eAAe,GAAGA,eAAe,CAC/BhB,GADgB,CACZ,CAAC,CAACD,GAAD,EAAME,UAAN,CAAD,KAAuBzB,sBAAsB,CAAC;AAClDR,YAAAA,KAAK,EAAEiC,UAD2C;AAElD/B,YAAAA,QAAQ,EAAEA,QAAQ,CAAC6B,GAAD,CAFgC;AAGlDtB,YAAAA,UAAU,EAAET,KAAK,CAACsB,IAHgC;AAIlDZ,YAAAA,aAJkD;AAKlDC,YAAAA,kBALkD;AAMlDC,YAAAA,qBANkD;AAOlDC,YAAAA,QAAQ,EAAEA,QAAQ,GAAG,CAP6B;AAQlDC,YAAAA,IAAI,EAAEA,IAAI,CAACoB,MAAL,CAAYlC,KAAK,CAACsB,IAAlB;AAR4C,WAAD,CAAtB,CASzBJ,QAVc,EAWhBY,MAXgB,CAWTK,GAAG,IAAIA,GAXE,EAYhBC,IAZgB,CAYX,IAZW,CAAlB;AAaAlB,UAAAA,QAAQ,IAAK,GAAE4B,UAAW,UAAS9B,IAAI,CAACM,IAAK,OAAM0B,eAAgB,KAAIF,UAAW,KAAlF;AACA,SArBD;AAsBA5B,QAAAA,QAAQ,IAAK,GAAE2B,MAAO,GAAtB;AACA;AACD;;AACD,WAAO;AAAE3B,MAAAA,QAAF;AAAYR,MAAAA;AAAZ,KAAP;AACA,GAxFD;;AA0FA,SAAOuC,4BAA4B,CAAC7C,IAAD,EAAOH,SAAP,EAAkBO,sBAAsB,CAAC;AAC3ER,IAAAA,KAAK,EAAEC,SADoE;AAE3EC,IAAAA,QAAQ,EAAEC,YAFiE;AAG3EM,IAAAA,UAAU,EAAEL;AAH+D,GAAD,CAAxC,CAAnC;AAKA,CAlHM;;;;AAoHP,SAAS6C,4BAAT,CAAsC7C,IAAtC,EAA4C8C,KAA5C,EAAmDC,WAAnD,EAAgE;AAC/D,QAAMC,cAAc,GAAG,8BAAkBD,WAAW,CAACzC,aAA9B,CAAvB;AACA,QAAM2C,KAAK,GAAGF,WAAW,CAACjC,QAA1B;AACA,SAAQ,GAAEd,IAAI,CAACkD,WAAL,EAAmB,IAAGJ,KAAK,CAAC5B,IAAK,GAAE8B,cAAc,GAAI,IAAGA,cAAe,GAAtB,GAA2B,EAAG,MAAKC,KAAM,KAApG;AACA;;AAEM,SAASE,WAAT,CAAqBC,MAArB,EAA6BnD,UAAU,GAAG,GAA1C,EAA+CC,MAAM,GAAGC,uBAAxD,EAA0E;AAEhF,QAAMkD,MAAM,GAAG,EAAf;AAEA,QAAMC,eAAe,GAAG;AACvBC,IAAAA,KAAK,EAAE,SADgB;AAEvBC,IAAAA,QAAQ,EAAE,WAFa;AAGvBC,IAAAA,YAAY,EAAE;AAHS,GAAxB;AAMA;;;;;;AAKA,QAAMC,WAAW,GAAG,CAACC,GAAD,EAAMC,WAAN,KAAsB;AACzC,UAAM5D,IAAI,GAAGsD,eAAe,CAACM,WAAD,CAAf,IACZC,qBAAcC,IAAd,CAAoB,+BAA8BF,WAAY,EAA9D,CADY,IAEX,GAAEG,MAAM,CAACH,WAAD,CAAN,CAAoBV,WAApB,EAAkC,GAFtC;AAGAG,IAAAA,MAAM,CAACrD,IAAD,CAAN,GAAe,EAAf;AACAsB,IAAAA,MAAM,CAACC,OAAP,CAAeoC,GAAf,EAAoBhB,OAApB,CAA4B,CAAC,CAAC/B,IAAD,EAAOhB,KAAP,CAAD,KAAmB;AAC9CyD,MAAAA,MAAM,CAACrD,IAAD,CAAN,CAAaY,IAAb,IAAqBjB,aAAa,CAAC;AAAEC,QAAAA,KAAF;AAASS,QAAAA,UAAU,EAAEuD,WAArB;AAAkC3D,QAAAA,UAAlC;AAA8CC,QAAAA;AAA9C,OAAD,CAAlC;AACA,KAFD;AAGA,GARD;;AAUA,MAAIkD,MAAM,CAACY,eAAP,EAAJ,EAA8B;AAC7BN,IAAAA,WAAW,CAACN,MAAM,CAACY,eAAP,GAAyBhD,SAAzB,EAAD,EAAuC,UAAvC,CAAX;AACA,GAFD,MAEO;AACN6C,yBAAcC,IAAd,CAAmB,uCAAnB;AACA;;AAED,MAAIV,MAAM,CAACa,YAAP,EAAJ,EAA2B;AAC1BP,IAAAA,WAAW,CAACN,MAAM,CAACa,YAAP,GAAsBjD,SAAtB,EAAD,EAAoC,OAApC,CAAX;AACA,GAFD,MAEO;AACN6C,yBAAcC,IAAd,CAAmB,oCAAnB;AACA;;AAED,MAAIV,MAAM,CAACc,mBAAP,EAAJ,EAAkC;AACjCR,IAAAA,WAAW,CAACN,MAAM,CAACc,mBAAP,GAA6BlD,SAA7B,EAAD,EAA2C,cAA3C,CAAX;AACA,GAFD,MAEO;AACN6C,yBAAcC,IAAd,CAAmB,2CAAnB;AACA;;AAED,SAAOT,MAAP;AACA","sourcesContent":["#!/usr/bin/env node\n\nimport { getArgsToVarsStr, getFieldArgsDict, getVarsToTypesStr, moduleConsole } from \"./utils\";\n\n/**\n * Generate the query for the specified field\n * @param field executable schema representative\n * @param rootSkeleton Object representation of fields in interest\n * @param kind of query - Actual Query or Mutation, Subscription\n * @param depthLimit\n * @param dedupe function to resolve query variables conflicts\n */\nexport const generateQuery = ({\n\t                              field: rootField,\n\t                              skeleton: rootSkeleton,\n\t                              kind = 'Query',\n\t                              depthLimit,\n\t                              dedupe = getFieldArgsDict\n}) => {\n\n\t/**\n\t * Generate the query for the specified field\n\t * @param field executable schema representative\n\t * @param skeleton Object representation of fields in interest\n\t * @param parentName parent name of the current field\n\t * @param argumentsDict dictionary of arguments from all fields\n\t * @param duplicateArgCounts map for deduping argument name collisions\n\t * @param crossReferenceKeyList list of the cross reference\n\t * @param curDepth current depth of field\n\t * @param path\n\t */\n\tconst generateQueryRecursive = ({\n\t\t                                field,\n\t\t                                skeleton,\n\t\t                                parentName,\n\t\t                                argumentsDict = {},\n\t\t                                duplicateArgCounts = {},\n\t\t                                crossReferenceKeyList = [], // [`${parentName}To${curName}Key`]\n\t\t                                curDepth = 1,\n\t\t                                path = []\n\t                                }) => {\n\t\tlet curType = field.type;\n\t\twhile (curType.ofType) curType = curType.ofType;\n\n\t\tlet queryStr = '';\n\t\tlet childQuery = '';\n\n\t\tif (curType.getFields) {\n\t\t\tconst crossReferenceKey = `${parentName}To${field.name}Key`;\n\t\t\tif (crossReferenceKeyList.indexOf(crossReferenceKey) !== -1 || curDepth > depthLimit) return '';\n\t\t\tcrossReferenceKeyList.push(crossReferenceKey);\n\t\t\tconst children = curType.getFields();\n\t\t\tchildQuery = Object.entries(children);\n\t\t\tif (skeleton) {\n\t\t\t\tconst skeletonKeys = Object.keys(skeleton);\n\t\t\t\tchildQuery = childQuery\n\t\t\t\t\t.filter(([key]) => skeletonKeys.indexOf(key) !== -1)\n\t\t\t} else skeleton = {};\n\t\t\tchildQuery = childQuery\n\t\t\t\t.map(([key, childField]) => generateQueryRecursive({\n\t\t\t\t\tfield: childField,\n\t\t\t\t\tskeleton: skeleton[key],\n\t\t\t\t\tparentName: field.name,\n\t\t\t\t\targumentsDict,\n\t\t\t\t\tduplicateArgCounts,\n\t\t\t\t\tcrossReferenceKeyList,\n\t\t\t\t\tcurDepth: curDepth + 1,\n\t\t\t\t\tpath: path.concat(field.name)\n\t\t\t\t}).queryStr)\n\t\t\t\t.filter(cur => cur)\n\t\t\t\t.join('\\n');\n\t\t}\n\n\t\tif (!(curType.getFields && !childQuery)) {\n\t\t\tqueryStr = `${'    '.repeat(curDepth)}${field.name}`;\n\t\t\tif (field.args.length > 0) {\n\t\t\t\tconst dict = dedupe(field, duplicateArgCounts, argumentsDict, path);\n\t\t\t\tObject.assign(argumentsDict, dict);\n\t\t\t\tqueryStr += `(${getArgsToVarsStr(dict)})`;\n\t\t\t}\n\t\t\tif (childQuery) {\n\t\t\t\tqueryStr += `{\\n${childQuery}\\n${'    '.repeat(curDepth)}}`;\n\t\t\t}\n\t\t}\n\n\t\t/* Union types */\n\t\tif (curType.astNode && curType.astNode.kind === 'UnionTypeDefinition') {\n\t\t\tconst types = curType.getTypes();\n\t\t\tif (types && types.length) {\n\t\t\t\tconst indent = `${'    '.repeat(curDepth)}`;\n\t\t\t\tconst fragIndent = `${'    '.repeat(curDepth + 1)}`;\n\t\t\t\tqueryStr += '{\\n';\n\n\t\t\t\ttypes.forEach(type => {\n\t\t\t\t\tlet unionChildQuery = Object.entries(type.getFields());\n\t\t\t\t\tif (skeleton && Object.keys(skeleton).length) {\n\t\t\t\t\t\tconst skeletonKeys = Object.keys(skeleton);\n\t\t\t\t\t\tunionChildQuery = unionChildQuery\n\t\t\t\t\t\t\t.filter(([key]) => skeletonKeys.indexOf(key) !== -1)\n\t\t\t\t\t} else skeleton = {};\n\t\t\t\t\tunionChildQuery = unionChildQuery\n\t\t\t\t\t\t.map(([key, childField]) => generateQueryRecursive({\n\t\t\t\t\t\t\tfield: childField,\n\t\t\t\t\t\t\tskeleton: skeleton[key],\n\t\t\t\t\t\t\tparentName: field.name,\n\t\t\t\t\t\t\targumentsDict,\n\t\t\t\t\t\t\tduplicateArgCounts,\n\t\t\t\t\t\t\tcrossReferenceKeyList,\n\t\t\t\t\t\t\tcurDepth: curDepth + 2,\n\t\t\t\t\t\t\tpath: path.concat(field.name)\n\t\t\t\t\t\t}).queryStr)\n\t\t\t\t\t\t.filter(cur => cur)\n\t\t\t\t\t\t.join('\\n');\n\t\t\t\t\tqueryStr += `${fragIndent}... on ${type.name} {\\n${unionChildQuery}\\n${fragIndent}}\\n`;\n\t\t\t\t});\n\t\t\t\tqueryStr += `${indent}}`;\n\t\t\t}\n\t\t}\n\t\treturn { queryStr, argumentsDict };\n\t};\n\n\treturn wrapQueryIntoKindDeclaration(kind, rootField, generateQueryRecursive({\n\t\tfield: rootField,\n\t\tskeleton: rootSkeleton,\n\t\tparentName: kind\n\t}));\n};\n\nfunction wrapQueryIntoKindDeclaration(kind, alias, queryResult) {\n\tconst varsToTypesStr = getVarsToTypesStr(queryResult.argumentsDict);\n\tconst query = queryResult.queryStr;\n\treturn `${kind.toLowerCase()} ${alias.name}${varsToTypesStr ? `(${varsToTypesStr})` : ''}{\\n${query}\\n}`;\n}\n\nexport function generateAll(schema, depthLimit = 100, dedupe = getFieldArgsDict) {\n\n\tconst result = {};\n\n\tconst QUERY_KINDS_MAP = {\n\t\tQuery: 'queries',\n\t\tMutation: 'mutations',\n\t\tSubscription: 'subscriptions'\n\t};\n\n\t/**\n\t * Generate the query for the specified field\n\t * @param obj one of the root objects(Query, Mutation, Subscription)\n\t * @param description description of the current object\n\t */\n\tconst addToResult = (obj, description) => {\n\t\tconst kind = QUERY_KINDS_MAP[description] ||\n\t\t\tmoduleConsole.warn(`unknown description string: ${description}`) ||\n\t\t\t`${String(description).toLowerCase()}s`;\n\t\tresult[kind] = {};\n\t\tObject.entries(obj).forEach(([type, field]) => {\n\t\t\tresult[kind][type] = generateQuery({ field, parentName: description, depthLimit, dedupe });\n\t\t});\n\t};\n\n\tif (schema.getMutationType()) {\n\t\taddToResult(schema.getMutationType().getFields(), 'Mutation');\n\t} else {\n\t\tmoduleConsole.warn('No mutation type found in your schema');\n\t}\n\n\tif (schema.getQueryType()) {\n\t\taddToResult(schema.getQueryType().getFields(), 'Query');\n\t} else {\n\t\tmoduleConsole.warn('No query type found in your schema');\n\t}\n\n\tif (schema.getSubscriptionType()) {\n\t\taddToResult(schema.getSubscriptionType().getFields(), 'Subscription');\n\t} else {\n\t\tmoduleConsole.warn('No subscription type found in your schema');\n\t}\n\n\treturn result;\n}"],"file":"index.js"}